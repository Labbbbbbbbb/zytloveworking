#include "TLE5012B.h"
#include <stdio.h>
float angle1;
float angle2;
int16_t ang_spd1;
int16_t ang_spd2;
void TLE5012B_SPI_RDATA()
{
    uint8_t data1[6];
    uint8_t data2[6];
    uint8_t cmd[2] = {0x80, 0x22};

    TLE5012B_SPI_MOSI1_GPIO_OUT();
    TLE5012B_CS1_LOW();
    //delay_us(1);
    HAL_SPI_Transmit(&hspi1, cmd, 2, 0xff);
    TLE5012B_SPI_MOSI1_GPIO_IN();
    HAL_SPI_Receive(&hspi1, data1, 6, 0xf);
    TLE5012B_SPI_MOSI1_GPIO_OUT();
    //delay_us(1);
    TLE5012B_CS1_HIGH();

    TLE5012B_SPI_MOSI2_GPIO_OUT();
    TLE5012B_CS2_LOW();
    //delay_us(1);
    HAL_SPI_Transmit(&hspi2, cmd, 2, 0xff);
    TLE5012B_SPI_MOSI2_GPIO_IN();
    HAL_SPI_Receive(&hspi2, data2, 6, 0xf);
    TLE5012B_SPI_MOSI2_GPIO_OUT();
    //delay_us(1);
    TLE5012B_CS2_HIGH();

    int16_t ang_temp1 = (((data1[0] << 8) | data1[1])<<1);
    angle1 = ang_temp1*360.0 / 65536.0;
    ang_spd1 = (((data1[2] << 8) | data1[3])<<1);

    int16_t ang_temp2 = (((data2[0] << 8) | data2[1])<<1);
    ang_spd2 = (((data2[2] << 8) | data2[3])<<1);
    angle2 = ang_temp2*360.0 / 65536.0;
    
    // printf("angle_right: %.3f \t angle_left: %.3f \t ang_spd_right: %3d \t ang_spd_left: %3d\t\n", angle1, angle2, ang_spd1, ang_spd2);
}


//CRC对照表
const unsigned char SPI_TableCRC[256] = 
{
	//The ¡°crc¡± of the position [1] (result from operation [crc ^*(message+Byteidx)])
	//is 0x00 -> 0x00 XOR 0x11D = 0x00 (1 byte).
	0x00,
	//The ¡°crc¡± of the position [2] is 0x1D -> 0x01 XOR 0x11D = 0x1D (1 byte).
	0x1D,
	//The ¡°crc¡± of the position [3] is 0x3A -> 0x02 XOR 0x11D = 0x3A (1 byte).
	0x3A,
	//For all the rest of the cases.
	0x27, 0x74, 0x69, 0x4E, 0x53, 0xE8, 0xF5, 0xD2, 0xCF, 0x9C, 0x81, 0xA6, 0xBB, 0xCD,
	0xD0, 0xF7, 0xEA, 0xB9, 0xA4, 0x83, 0x9E, 0x25, 0x38, 0x1F, 0x02, 0x51, 0x4C, 0x6B,
	0x76, 0x87, 0x9A, 0xBD, 0xA0, 0xF3, 0xEE, 0xC9, 0xD4, 0x6F, 0x72, 0x55, 0x48, 0x1B,
	0x06, 0x21, 0x3C, 0x4A, 0x57, 0x70, 0x6D, 0x3E, 0x23, 0x04, 0x19, 0xA2, 0xBF, 0x98,
	0x85, 0xD6, 0xCB, 0xEC, 0xF1, 0x13, 0x0E, 0x29, 0x34, 0x67, 0x7A, 0x5D, 0x40, 0xFB,
	0xE6, 0xC1, 0xDC, 0x8F, 0x92, 0xB5, 0xA8, 0xDE, 0xC3, 0xE4, 0xF9, 0xAA, 0xB7, 0x90,
	0x8D, 0x36, 0x2B, 0x0C, 0x11, 0x42, 0x5F, 0x78, 0x65, 0x94, 0x89, 0xAE, 0xB3, 0xE0,
	0xFD, 0xDA, 0xC7, 0x7C, 0x61, 0x46, 0x5B, 0x08, 0x15, 0x32, 0x2F, 0x59, 0x44, 0x63,
	0x7E, 0x2D, 0x30, 0x17, 0x0A, 0xB1, 0xAC, 0x8B, 0x96, 0xC5, 0xD8, 0xFF, 0xE2, 0x26,
	0x3B, 0x1C, 0x01, 0x52, 0x4F, 0x68, 0x75, 0xCE, 0xD3, 0xF4, 0xE9, 0xBA, 0xA7, 0x80,
	0x9D, 0xEB, 0xF6, 0xD1, 0xCC, 0x9F, 0x82, 0xA5, 0xB8, 0x03, 0x1E, 0x39, 0x24, 0x77,
	0x6A, 0x4D, 0x50, 0xA1, 0xBC, 0x9B, 0x86, 0xD5, 0xC8, 0xEF, 0xF2, 0x49, 0x54, 0x73,
	0x6E, 0x3D, 0x20, 0x07, 0x1A, 0x6C, 0x71, 0x56, 0x4B, 0x18, 0x05, 0x22, 0x3F, 0x84,
	0x99, 0xBE, 0xA3, 0xF0, 0xED, 0xCA, 0xD7, 0x35, 0x28, 0x0F, 0x12, 0x41, 0x5C, 0x7B,
	0x66, 0xDD, 0xC0, 0xE7, 0xFA, 0xA9, 0xB4, 0x93, 0x8E, 0xF8, 0xE5, 0xC2, 0xDF, 0x8C,
	0x91, 0xB6, 0xAB, 0x10, 0x0D, 0x2A, 0x37, 0x64, 0x79, 0x5E, 0x43, 0xB2, 0xAF, 0x88,
	0x95, 0xC6, 0xDB, 0xFC, 0xE1, 0x5A, 0x47, 0x60, 0x7D, 0x2E, 0x33, 0x14, 0x09, 0x7F,
	0x62, 0x45, 0x58, 0x0B, 0x16, 0x31, 0x2C, 0x97, 0x8A, 0xAD, 0xB0, 0xE3, 0xFe,
	//The ¡°crc¡± of the position [255] is 0xD9 -> 0xFE XOR 0x11D = 0xD9 (1 byte).
	0xD9,
	//The ¡°crc¡± of the position [256] is 0xC4 -> 0xFF XOR 0x11D = 0xC4 (1 byte).
	0xC4
};

//配置
unsigned char SPI_CRC8(unsigned char *message, unsigned char Bytelength )
{
	//¡°crc¡± defined as the 8-bits that will be generated through the message till the
	//final crc is generated. In the example above this are the blue lines out of the
	//XOR operation.
	unsigned char crc;
	//¡°Byteidx¡± is a counter to compare the bytes used for the CRC calculation and
	//¡°Bytelength¡±.
	unsigned char Byteidx;
	//Initially the CRC remainder has to be set with the original seed (0xFF for the TLE5012B).
	crc = 0xFF;
	//For all the bytes of the message.
	for(Byteidx=0; Byteidx<Bytelength; Byteidx++)
	{
		//¡°crc¡± is the value in the look-up table TableCRC[x] at the position ¡°x¡±.
		//The position ¡°x¡± is determined as the XOR operation between the previous ¡°crc¡± and
		//the next byte of the ¡°message¡±.
		//¡°^¡± is the XOR operator.
		crc = SPI_TableCRC[crc ^ *(message+Byteidx)];
	}
	//Return the inverted ¡°crc¡± remainder(¡°~¡± is the invertion operator). An alternative
	//to the ¡°~¡± operator would be a XOR operation between ¡°crc¡± and a 0xFF polynomial.
	return(~crc);
}
